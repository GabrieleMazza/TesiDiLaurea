#Creazione della frontiera in poligono unico usamdo una tecnica di smoothing
#Funzioni di appoggio
source("Functions.R")
library(fda)
library(KernSmooth)
library(geosphere)
library(fda)
library(RTriangle)
library(SDMTools)
##### DOWNLOAD DELLA FRONTIERA #####
#Scarico la frontiera
#require(raster)
#veneto =  subset(getData('GADM', country='ITA', level=1), NAME_1=="Veneto")
#plot(veneto)
#save(file="Veneto.RData",veneto)
load("Veneto.RData")
#La frontiera è memorizzata come una unione di 130 poligoni (a causa delle isole della)
#laguna veneta)
#Prendo solo la regione, ed è formata da un poligono di 20000 vertici.. lo riduco in base
#alla tolleranza indicata
#pIù bassa è la tolleranza, più punti sono tenuti per il poligono di confine
tmp<- slot(veneto, 'polygons')
sub.tmp <- slot(tmp[[1]],'Polygons')
order<-slot(tmp[[1]],'plotOrder')
xbound<-NULL
ybound<-NULL
labels<-NULL
for(i in 1:131)
{
xbound<-c(xbound,sub.tmp[[order[i]]]@coords[,1])
ybound<-c(ybound,sub.tmp[[order[i]]]@coords[,2])
labels<-c(labels,rep(i,length(sub.tmp[[order[i]]]@coords[,1])))
}
length(xbound)
length(ybound)
length(labels)
#Leggo anche i comuni
Comuni<-read.table(file="Coordinate.txt",header=T)
##### VENETO #####
#Ora devo studiare il caso del Veneto
#Il Veneto è nel poligono 1
#Studio tutti i dati in dipendenza dall'ascissa curvilinea
xVeneto_tot=xbound[labels==1]
yVeneto_tot=ybound[labels==1]
s<-0
previous<-0
for(i in 2:length(xVeneto_tot))
{
#Aggiorno la distanza
previous<-previous+sqrt((xVeneto_tot[i]-xVeneto_tot[i-1])^2+(yVeneto_tot[i]-yVeneto_tot[i-1])^2)
s<-c(s,previous)
}
#Ora devo fare smoothing di queste due funzioni
#Come si fa?
#Quanti punti fisso per la definizione del confine?
N<-150
#Nel range di ascissa curvilinea fisso N punti
Val<-seq(0,max(s),by=max(s)/N)
#Decido di usare delle splines cubiche
m<-4
##### REGRESSION SPLINES #####
#Scelgo come upper bound il numero di punti della valutazione per il numero di basi con
#cui comporre la frontiera
#Come scelgo l'ottimo del numero di basi?
#Mi interessa che sia minimizzata la distanza totale quadratica euclidea
#poligono reale del Veneto
bestsum<-9999999999999
best<-0
sum_vect<-NULL
best_vect<-NULL
#Qui mi salvo un po' di risultati numerici
sink(file = "ROutput.txt", append = FALSE)
print("nbasis sum best Intersections Trinagoli Comuni")
for(nbasis in 110:N)
{
basis = create.bspline.basis(c(0,max(s)), nbasis, m)
xsmooth = smooth.basis(argvals=s, y=xVeneto_tot, basis)
ysmooth = smooth.basis(argvals=s, y=yVeneto_tot, basis)
xVeneto  = eval.fd(Val, xsmooth$fd)
yVeneto  = eval.fd(Val, ysmooth$fd)
png(filename = paste(nbasis,".png",sep=""))
plot(xVeneto_tot,yVeneto_tot,type='l',main=paste(nbasis,sep=""))
points(xVeneto,yVeneto,col="blue",type='l')
dev.off()
sum=0
for(i in 1:N)
{
sum<-sum+dist2Line(c(xVeneto[i],yVeneto[i]), cbind(xVeneto_tot,yVeneto_tot), distfun=SquareEuclideanDistance)[1]
}
if(sum<bestsum)
{
best<-nbasis
bestsum=sum
}
png(filename = paste("Regione",nbasis,".png",sep=""))
plot(xVeneto_tot,yVeneto_tot,type='l',main="Nuova definizione della regione")
points(xVeneto,yVeneto,col="blue",type='l')
dev.off()
Intersect<-Intersections(xVeneto,yVeneto)
#Oggetti completi
x<-c(Comuni$Longitudine,xVeneto)
y<-c(Comuni$Latitudine,yVeneto)
#Creo i Boundaries
Boundaries<-NULL
for(i in (length(Comuni$Longitudine)+1):length(x))
{
Boundaries<-rbind(Boundaries, c(i,i+1))
}
Boundaries<-rbind(Boundaries, c(length(x),length(Comuni$Longitudine)+1))
#Ora triangolazione
#Oggetto pslg
pslg_obj<-pslg(cbind(x,y),S=Boundaries)
#Creo la mesh
#Y dice di non aggiungere Steiner Points
#D dice di triangolare con Delaunay
mesh<-triangulate(pslg_obj,Y=TRUE,D=TRUE)
#Estrazione dei triangoli
Triang<-mesh$T
#Plot della triangolazione
png(filename = paste("Triangolazione nella laguna ", nbasis, ".png", sep=""))
plot(x,y,col="white")
for (ne in 1:dim(Triang)[1])
{
polygon(c(x[Triang[ne,1]],x[Triang[ne,2]],x[Triang[ne,3]]),c(y[Triang[ne,1]],y[Triang[ne,2]],y[Triang[ne,3]]))
}
#Controllo se la triangolazione ha triangoli con solo punti di bordo
BorderTR<-BorderTriangles(mesh$T,Boundaries)
BorderTR
#Li coloro
for (ne in BorderTR)
{
polygon(c(x[Triang[ne,1]],x[Triang[ne,2]],x[Triang[ne,3]]),c(y[Triang[ne,1]],y[Triang[ne,2]],y[Triang[ne,3]]),col="green")
}
#Ci sono comuni esterni alla frontiera?
PolyPoints<-cbind(xVeneto,yVeneto)
points(Comuni$Longitudine[pnt.in.poly(cbind(Comuni$Longitudine,Comuni$Latitudine),PolyPoints)$pip==0],Comuni$Latitudine[pnt.in.poly(cbind(Comuni$Longitudine,Comuni$Latitudine),PolyPoints)$pip==0],col="red",pch=16)
dev.off()
length(pnt.in.poly(cbind(Comuni$Longitudine,Comuni$Latitudine),PolyPoints)$pip==0)
comuniout=580-length(Comuni$Longitudine[pnt.in.poly(cbind(Comuni$Longitudine,Comuni$Latitudine),PolyPoints)$pip==0])
print(paste(
nbasis,
sum,
best,
dim(Intersect)[1],
length(BorderTR),
comuniout,
sep=" "))
sum_vect<-c(sum_vect,sum)
best_vect<-c(best_vect,best)
}
#Creazione della frontiera in poligono unico usamdo una tecnica di smoothing
#Funzioni di appoggio
source("Functions.R")
library(fda)
library(KernSmooth)
library(geosphere)
library(fda)
library(RTriangle)
library(SDMTools)
##### DOWNLOAD DELLA FRONTIERA #####
#Scarico la frontiera
#require(raster)
#veneto =  subset(getData('GADM', country='ITA', level=1), NAME_1=="Veneto")
#plot(veneto)
#save(file="Veneto.RData",veneto)
load("Veneto.RData")
#La frontiera è memorizzata come una unione di 130 poligoni (a causa delle isole della)
#laguna veneta)
#Prendo solo la regione, ed è formata da un poligono di 20000 vertici.. lo riduco in base
#alla tolleranza indicata
#pIù bassa è la tolleranza, più punti sono tenuti per il poligono di confine
tmp<- slot(veneto, 'polygons')
sub.tmp <- slot(tmp[[1]],'Polygons')
order<-slot(tmp[[1]],'plotOrder')
xbound<-NULL
ybound<-NULL
labels<-NULL
for(i in 1:131)
{
xbound<-c(xbound,sub.tmp[[order[i]]]@coords[,1])
ybound<-c(ybound,sub.tmp[[order[i]]]@coords[,2])
labels<-c(labels,rep(i,length(sub.tmp[[order[i]]]@coords[,1])))
}
length(xbound)
length(ybound)
length(labels)
#Leggo anche i comuni
Comuni<-read.table(file="Coordinate.txt",header=T)
##### VENETO #####
#Ora devo studiare il caso del Veneto
#Il Veneto è nel poligono 1
#Studio tutti i dati in dipendenza dall'ascissa curvilinea
xVeneto_tot=xbound[labels==1]
yVeneto_tot=ybound[labels==1]
s<-0
previous<-0
for(i in 2:length(xVeneto_tot))
{
#Aggiorno la distanza
previous<-previous+sqrt((xVeneto_tot[i]-xVeneto_tot[i-1])^2+(yVeneto_tot[i]-yVeneto_tot[i-1])^2)
s<-c(s,previous)
}
#Ora devo fare smoothing di queste due funzioni
#Come si fa?
#Quanti punti fisso per la definizione del confine?
N<-150
#Nel range di ascissa curvilinea fisso N punti
Val<-seq(0,max(s),by=max(s)/N)
#Decido di usare delle splines cubiche
m<-4
##### REGRESSION SPLINES #####
#Scelgo come upper bound il numero di punti della valutazione per il numero di basi con
#cui comporre la frontiera
#Come scelgo l'ottimo del numero di basi?
#Mi interessa che sia minimizzata la distanza totale quadratica euclidea
#poligono reale del Veneto
bestsum<-9999999999999
best<-0
sum_vect<-NULL
best_vect<-NULL
#Qui mi salvo un po' di risultati numerici
sink(file = "ROutput.txt", append = FALSE)
print("nbasis sum best Intersections Trinagoli Comuni")
for(nbasis in 110:N)
{
basis = create.bspline.basis(c(0,max(s)), nbasis, m)
xsmooth = smooth.basis(argvals=s, y=xVeneto_tot, basis)
ysmooth = smooth.basis(argvals=s, y=yVeneto_tot, basis)
xVeneto  = eval.fd(Val, xsmooth$fd)
yVeneto  = eval.fd(Val, ysmooth$fd)
png(filename = paste(nbasis,".png",sep=""))
plot(xVeneto_tot,yVeneto_tot,type='l',main=paste(nbasis,sep=""))
points(xVeneto,yVeneto,col="blue",type='l')
dev.off()
sum=0
for(i in 1:N)
{
sum<-sum+dist2Line(c(xVeneto[i],yVeneto[i]), cbind(xVeneto_tot,yVeneto_tot), distfun=SquareEuclideanDistance)[1]
}
if(sum<bestsum)
{
best<-nbasis
bestsum=sum
}
png(filename = paste("Regione",nbasis,".png",sep=""))
plot(xVeneto_tot,yVeneto_tot,type='l',main="Nuova definizione della regione")
points(xVeneto,yVeneto,col="blue",type='l')
dev.off()
Intersect<-Intersections(xVeneto,yVeneto)
#Oggetti completi
x<-c(Comuni$Longitudine,xVeneto)
y<-c(Comuni$Latitudine,yVeneto)
#Creo i Boundaries
Boundaries<-NULL
for(i in (length(Comuni$Longitudine)+1):length(x))
{
Boundaries<-rbind(Boundaries, c(i,i+1))
}
Boundaries<-rbind(Boundaries, c(length(x),length(Comuni$Longitudine)+1))
#Ora triangolazione
#Oggetto pslg
pslg_obj<-pslg(cbind(x,y),S=Boundaries)
#Creo la mesh
#Y dice di non aggiungere Steiner Points
#D dice di triangolare con Delaunay
mesh<-triangulate(pslg_obj,Y=TRUE,D=TRUE)
#Estrazione dei triangoli
Triang<-mesh$T
#Plot della triangolazione
png(filename = paste("Triangolazione nella laguna ", nbasis, ".png", sep=""))
plot(x,y,col="white")
for (ne in 1:dim(Triang)[1])
{
polygon(c(x[Triang[ne,1]],x[Triang[ne,2]],x[Triang[ne,3]]),c(y[Triang[ne,1]],y[Triang[ne,2]],y[Triang[ne,3]]))
}
#Controllo se la triangolazione ha triangoli con solo punti di bordo
BorderTR<-BorderTriangles(mesh$T,Boundaries)
BorderTR
#Li coloro
for (ne in BorderTR)
{
polygon(c(x[Triang[ne,1]],x[Triang[ne,2]],x[Triang[ne,3]]),c(y[Triang[ne,1]],y[Triang[ne,2]],y[Triang[ne,3]]),col="green")
}
#Ci sono comuni esterni alla frontiera?
PolyPoints<-cbind(xVeneto,yVeneto)
points(Comuni$Longitudine[pnt.in.poly(cbind(Comuni$Longitudine,Comuni$Latitudine),PolyPoints)$pip==0],Comuni$Latitudine[pnt.in.poly(cbind(Comuni$Longitudine,Comuni$Latitudine),PolyPoints)$pip==0],col="red",pch=16)
dev.off()
length(pnt.in.poly(cbind(Comuni$Longitudine,Comuni$Latitudine),PolyPoints)$pip==0)
comuniout=580-length(Comuni$Longitudine[pnt.in.poly(cbind(Comuni$Longitudine,Comuni$Latitudine),PolyPoints)$pip==0])
print(paste(
nbasis,
sum,
best,
dim(Intersect)[1],
length(BorderTR),
comuniout,
sep=" "))
sum_vect<-c(sum_vect,sum)
best_vect<-c(best_vect,best)
}
sink()
png(filename = "Sum.png")
plot(sum_vect,type='l')
dev.off()
png(filename = "Best.png")
plot(best_vect,type='l')
dev.off()
